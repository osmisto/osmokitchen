require 'pry'

class Vote
  include Ripple::Document

  before_create :validate_idea_existence
  before_create :validate_duplication

  before_update :update_idea
  before_create :update_idea_on_create
  before_destroy :update_idea_on_destroy

  property :id, String
  key_on :id
  timestamps!

  # Own properties
  property :cache, Float, :default => 0
  property :body, String
  are_safe :cache, :body

  # Idea
  property :idea_key, String, :presence => true, :index => true
  one :idea, :using => :stored_key

  # Author, and cached data
  property :author_key, String, :presence => true, :index => true
  property :author_nick, String, :presence => true
  property :author_hash, String, :presence => true
  one :author, :using => :stored_key, :class_name => "User"


  private
  def validate_idea_existence
    Idea.find!(self.idea_key)
  end

  def validate_duplication
    if Vote.query({:author_key => self.author_key, :idea_key => self.idea_key}).any?
      raise "Second vote is not allowed, please, edit old one if you need add more"
    end
  end

  def update_idea
    self.idea.cache +=  - self.cache_was + self.cache
    self.idea.save
  end

  def update_idea_on_create
    self.idea.votes += 1
    self.idea.cache += self.cache
    self.idea.save
  end

  def update_idea_on_destroy
    self.idea.votes -= 1
    self.idea.cache -= self.cache
    self.idea.save
  end

  def self.create_new(author, idea, values = {})
    puts author.inspect
    vote = self.new({
      # :idea_key => idea.respond_to?(:id) ? idea.id : idea, // TODO: remove
      :idea_key => idea.id,
      :author_key => author.id,
      :author_nick => author.nick,
      :author_hash => author[:hash]
    })
    puts vote.inspect
    vote.safe_update(values)
    puts vote.inspect
    vote.save!
    puts vote.inspect
    vote.save # save autogenerated :id (fixme)
    puts vote.inspect
    vote
  end
end
